<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The agb book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="hardware/hardware.html"><strong aria-hidden="true">2.</strong> The Game Boy Advance hardware</a></li><li class="chapter-item expanded "><a href="setup/getting_started.html"><strong aria-hidden="true">3.</strong> Running an example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/setup.html"><strong aria-hidden="true">3.1.</strong> Environment setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/linux.html"><strong aria-hidden="true">3.1.1.</strong> Linux setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.2.</strong> Windows setup</div></li><li class="chapter-item expanded "><a href="setup/mac.html"><strong aria-hidden="true">3.1.3.</strong> Mac OS setup</a></li></ol></li><li class="chapter-item expanded "><a href="setup/building.html"><strong aria-hidden="true">3.2.</strong> Building the template</a></li></ol></li><li class="chapter-item expanded "><a href="pong/01_introduction.html"><strong aria-hidden="true">4.</strong> Learn agb part I - pong</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pong/02_the_gba_struct.html"><strong aria-hidden="true">4.1.</strong> The Gba struct</a></li><li class="chapter-item expanded "><a href="pong/03_sprites.html"><strong aria-hidden="true">4.2.</strong> Sprites</a></li><li class="chapter-item expanded "><a href="pong/04_controls.html"><strong aria-hidden="true">4.3.</strong> Controls</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The agb book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>agb</strong> is a library for writing games for the Game Boy Advance (GBA) in rust.
It is intended to make the process of producing games for the Game Boy Advance as easy as possible by giving you access to the hardware in an abstracted format, which allows you to take advantage of all that it has to offer, without needing to know the specifics of how it is implemented.</p>
<h1 id="what-is-in-this-book"><a class="header" href="#what-is-in-this-book">What is in this book?</a></h1>
<p>This book is intended as an introduction to what <strong>agb</strong> has to offer, and should set you up nicely to start writing games of your own.
This book will not give a thorough overview of the specifics of the hardware implementation of the GBA unless it is needed as part of an explanation.
An overview of the hardware can be found in chapter 2.</p>
<h1 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this book for?</a></h1>
<p>This book is for:</p>
<ul>
<li><strong>People who want to make games for the GBA.</strong> First and foremost, games written using agb cannot run on any other platform except the GBA and emulators. If you don't want to write a game for the GBA, you should probably use a different library.</li>
<li><strong>People who have experience in rust.</strong> Unless the rust specific syntax or semantics are important, we will not discuss details here and instead recommend reading the rust book before coming back.</li>
<li><strong>People with experience in writing games.</strong> Game programming is hard, and harder still in rust on a GBA. We recommend writing a game for a more user friendly platform before coming back here.</li>
</ul>
<p>If you fit into all of those categories, welcome!
It is super rewarding being able to play a game you made yourself on a piece of 20+ year old hardware.</p>
<h1 id="helpful-links"><a class="header" href="#helpful-links">Helpful links</a></h1>
<ul>
<li><a href="https://github.com/agbrs/agb">agb's GitHub</a> all development happens here</li>
<li><a href="https://github.com/agbrs/agb/discussions">agb's Discussion Page</a> a forum where you can ask for help on the usage of agb</li>
<li><a href="https://crates.io/crates/agb">agb's crates.io page</a></li>
<li><a href="https://docs.rs/agb">agb's documentation</a> which is useful if you need a quick reference</li>
<li><a href="https://github.com/gbdev/awesome-gbadev">Awesome Game Boy Advance development</a> contains links to popular libraries, emulators and the super friendly gbadev discord</li>
<li><a href="https://lostimmortal.itch.io/the-hat-chooses-the-wizard">Example game</a> written using agb as part of the 2021 GMTK game jam.</li>
<li><a href="https://github.com/agbrs/agb/releases/latest">More example games</a> built using agb. See them in <code>examples.zip</code> attached to the latest release.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-game-boy-advance-hardware"><a class="header" href="#the-game-boy-advance-hardware">The Game Boy Advance hardware</a></h1>
<p>The Game Boy Advance was released by Nintendo in Japan in March 2001 and in North America in the following June.
It has a 2.9 inch screen with a 240x144 pixel resolution, and contains a 32-bit 16.8MHz ARM CPU.
It was developed to be the successor to the Game Boy Color and internally codenamed the 'Advanced Game Boy' (agb) which is where this crate gets its name.</p>
<h1 id="what-makes-the-gba-unique"><a class="header" href="#what-makes-the-gba-unique">What makes the GBA unique?</a></h1>
<p>The Game Boy Advance is (fairly) unique amongst retro handheld consoles.
It was developed at a time where processors weren't powerful enough to be able to push an entire screen of pixels to the screen every frame.
Therefore, it has a special Pixel Processing Unit (PPU) which is sort of similar to a modern day graphics card, except it is very games focused.
For example, the GBA has a concept of 'hardware sprites' and 'hardware backgrounds' which we'll go in to more detail in the next section.
This hardware 2d capabilities gives the GBA the unique characteristics with the games developed for it.</p>
<p>However, despite this, it is possible to write code for it using modern tools and programming languages thanks to the ARM CPU it contains.
The CPU is modern enough to be supported by LLVM and rust to give a reasonably trouble free experience.</p>
<p>So the GBA lets you take advantage of modern tooling while also giving you the ability to see what programming for retro consoles was like at the time!</p>
<h1 id="capabilities-of-the-hardware"><a class="header" href="#capabilities-of-the-hardware">Capabilities of the hardware</a></h1>
<p>The GBA is fundamentally a 2D system, and a lot of the hardware accelerated graphics is designed to support this.
The relevant features for this book are:</p>
<ul>
<li>256 sprites which can be from 8x8 to 64x64 pixels in size</li>
<li>4 background layers which are enabled / disabled depending on the graphics mode</li>
<li>Background tiles, 8x8 pixel tiles are used in the background layers if they are in tile mode.</li>
<li>8-bit sound. You have the ability to send 8-bit raw audio data to the speakers (optionally stereo).</li>
</ul>
<p>You can read more about the specifics of the GBA on <a href="https://rust-console.github.io/gbatek-gbaonly/">gbatek</a>.</p>
<p>agb tries to abstract some of this away from you to give you less to remember and less that can go wrong.
If you want to try playing around directly with the hardware, the best place to look is <a href="https://www.coranac.com/tonc/text/">tonc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-an-example"><a class="header" href="#running-an-example">Running an example</a></h1>
<p>In this section, we will get to the point where you can build and run the game built for the GMTK game jam using agb known as 'The Hat Chooses the Wizard'.
This will prove that your development environment is ready for the future tutorials and later building.</p>
<p>You can run the game using real hardware and a flash card.
However, at this stage, it is much easier to play on an emulator.
agb is guaranteed to work well using <a href="https://mgba.io/">mgba</a>, but other emulators will also work.</p>
<p>Note that some emulators will require a special 'fixed' gba ROM file.
See the later steps in this section for how to do this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup"><a class="header" href="#environment-setup">Environment setup</a></h1>
<p>Environment setup will depend on the platform you are using.
agb's requirements are <a href="https://www.rust-lang.org/">rust nightly</a> edition and the gnu binutils for <code>arm-none-eabi</code>.</p>
<p>See the sub-pages here for platform specific setup guides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-setup"><a class="header" href="#linux-setup">Linux setup</a></h1>
<p>This guide has been tested on Ubuntu, Arch Linux and Raspberry Pi OS running on a raspberry pi 4.</p>
<h1 id="1-install-a-recent-version-of-rust"><a class="header" href="#1-install-a-recent-version-of-rust">1. Install a recent version of rust</a></h1>
<p>agb unfortunately relies on a few nightly rust features, so you need to ensure you have that installed.
Firstly, ensure that you have <strong>rustup</strong> installed which you can do by following the instructions on the <a href="https://www.rust-lang.org/tools/install">rust website</a></p>
<p>You can update rustup with <code>rustup update</code> if you have already installed it.</p>
<h1 id="2-arm-none-eabi"><a class="header" href="#2-arm-none-eabi">2. arm-none-eabi</a></h1>
<p>We need this installed in order to be able to assemble the small amount of assembly in agb, and to do the final linking.</p>
<ul>
<li>On Debian and derivatives (like Ubuntu): <code>sudo apt install binutils-arm-none-eabi</code></li>
<li>On Arch Linux and derivatives: <code>pacman -S arm-none-eabi-binutils</code></li>
</ul>
<h1 id="3-git"><a class="header" href="#3-git">3. git</a></h1>
<p>The source code for the game is hosted on github, so you will need git installed.</p>
<ul>
<li>On Debian and derivatives (like Ubuntu): <code>sudo apt install git</code></li>
<li>On Arch Linux and derivatives: <code>pacman -S git</code></li>
</ul>
<h1 id="4-gbafix"><a class="header" href="#4-gbafix">4. gbafix</a></h1>
<p>In order to be able to play on real hardware or on some emulators, you may need to install 'gbafix'.
The rust implementation can be installed very easily using <code>cargo install gbafix</code>.</p>
<p>Make sure that the Cargo bin directory is in your <code>PATH</code> as we'll need to use it later.</p>
<p>That is all you need to get started.
You can now move on to 'building the game'.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac-setup"><a class="header" href="#mac-setup">Mac setup</a></h1>
<p>This guide has been tested on MacOS 13.0.1 on an M1 chip.</p>
<h1 id="1-install-a-recent-version-of-rust-1"><a class="header" href="#1-install-a-recent-version-of-rust-1">1. Install a recent version of rust</a></h1>
<p>agb unfortunately relies on a few nightly rust features, so you need to ensure you have that installed.
Firstly, ensure that you have <strong>rustup</strong> installed which you can do by following the instructions on the <a href="https://www.rust-lang.org/tools/install">rust website</a></p>
<p>You can update rustup with <code>rustup update</code> if you have already installed it.</p>
<h1 id="2-install-arm-none-eabi"><a class="header" href="#2-install-arm-none-eabi">2. Install arm-none-eabi</a></h1>
<p>We need this installed in order to be able to assemble the small amount of assembly in agb, and to do the final linking.</p>
<h2 id="install-from-arm"><a class="header" href="#install-from-arm">Install from ARM</a></h2>
<p>Download the toolchain from <a href="https://developer.arm.com/downloads/-/gnu-rm">ARM here</a></p>
<ul>
<li>Run the .pkg to install</li>
<li>Add <code>/Applications/ARM/bin</code> to your <code>/etc/paths</code> file</li>
</ul>
<h2 id="install-from-homebrew"><a class="header" href="#install-from-homebrew">Install from Homebrew</a></h2>
<p>Or you can try installing with homebrew from the <a href="https://github.com/ARMmbed/homebrew-formulae">Arm Mbed repo</a>:</p>
<pre><code>brew tap ArmMbed/homebrew-formulae
brew install arm-none-eabi-gcc
</code></pre>
<h1 id="3-get-git"><a class="header" href="#3-get-git">3. Get git</a></h1>
<p>The source code for the game is hosted on github, so you will need git installed. Follow the instructions at <a href="https://git-scm.com/">git-scm.com</a></p>
<h1 id="4-gba-emulator---mgba"><a class="header" href="#4-gba-emulator---mgba">4. GBA Emulator - mGBA</a></h1>
<p>We recommend using the mGBA emulator which you can download for Mac <a href="https://mgba.io/downloads.html">here</a>.</p>
<p>After installing to your <code>/Applications</code> folder you can add the binary to your path and create an alias for the agb run command to use.</p>
<ul>
<li>Add <code>/Applications/mGBA.app/Contents/MacOS</code> to <code>/etc/paths</code></li>
<li>Inside the <code>/Applications/mGBA.app/Contents/MacOS</code> directory (in a terminal) run: <code>ln -s mGBA mgba-qt</code></li>
</ul>
<h1 id="5-real-hardware---gbafix"><a class="header" href="#5-real-hardware---gbafix">5. Real hardware - gbafix</a></h1>
<p>In order to be able to play on real hardware or on some emulators, you may need to install 'gbafix'.
The rust implementation can be installed very easily using <code>cargo install gbafix</code>.</p>
<p>Make sure that the Cargo bin directory is in your <code>PATH</code> as we'll need to use it later.</p>
<p>That is all you need to get started.
You can now move on to 'building the game'.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-template"><a class="header" href="#building-the-template">Building the template</a></h1>
<p>By the end of this section, you should be able to build and run the <strong>agb</strong> template.</p>
<h1 id="1-get-the-source-code"><a class="header" href="#1-get-the-source-code">1. Get the source code</a></h1>
<p>The source code can be fetched using <code>git clone https://github.com/agbrs/template.git</code>.</p>
<h1 id="2-build-the-template"><a class="header" href="#2-build-the-template">2. Build the template</a></h1>
<p>Build a copy of the template using <code>cargo build --release</code>.
This could take quite a while, but eventually you'll end up with a copy of the template in <code>target/thumbv4t-none-eabi/release/template</code> or <code>target/thumbv4t-none-eabi/release/template.elf</code> depending on platform.</p>
<p>This can be run directly by some emulators, but we need to run an extra step in order to convert the elf file into a '.gba' file.</p>
<pre><code class="language-sh">arm-none-eabi-objcopy -O binary target/thumbv4t-none-eabi/release/template template.gba
gbafix template.gba
</code></pre>
<p>or</p>
<pre><code class="language-sh">arm-none-eabi-objcopy -O binary target/thumbv4t-none-eabi/release/template.elf template.gba
gbafix template.gba
</code></pre>
<p>And then load the resulting file in your emulator of choice.
That's all there is to it!</p>
<p>If you have <code>mgba-qt</code> in your path, then you can launch the template directly using <code>cargo run --release</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learn-agb-part-i---pong"><a class="header" href="#learn-agb-part-i---pong">Learn agb part I - pong</a></h1>
<p>In this section, we'll make a simple pong style game for the Game Boy Advance using <code>agb</code>.
You will learn:</p>
<ul>
<li>How to use tiled graphics modes.</li>
<li>How to import graphics using <code>agb</code>.</li>
<li>What Game Boy Advance sprites are and how to put them on the screen.</li>
<li>How to detect button input and react to it.</li>
<li>How to add a static background.</li>
<li>How to make a dynamic background for a score display.</li>
<li>How to add music to your game.</li>
<li>How to add sound effects to your game.</li>
</ul>
<p>With this knowledge, you'll be well equipped to start making your own games!</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>To start, create a new repository based on the <a href="https://github.com/agbrs/template">agb template</a>.
We'll call this <code>pong</code>.</p>
<p>Then replace the <code>name</code> field in <code>Cargo.toml</code> with <code>pong</code>, to end up with something similar to:</p>
<pre><code class="language-toml">[package]
name = &quot;pong&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your name here&quot;]
edition = &quot;2018&quot;

# ...
</code></pre>
<p>You are now ready to get started learning about how <code>agb</code> works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gba-struct"><a class="header" href="#the-gba-struct">The Gba struct</a></h1>
<p>In this section, we'll cover the importance of the Gba struct and how it gets created for you.</p>
<h1 id="the-importance-of-the-gba-struct"><a class="header" href="#the-importance-of-the-gba-struct">The importance of the Gba struct</a></h1>
<p>Almost all interaction with the Game Boy Advance's hardware goes through the <a href="https://docs.rs/agb/latest/agb/struct.Gba.html">Gba singleton struct</a>.
You should not create the Gba struct yourself, instead having it be passed into your main function.</p>
<p>The Gba struct is used to take advantage of rust's borrow checker, and lean on it to ensure that access to the Game Boy Advance hardware is done 'sensibly'.
You won't have to worry about 2 bits of your code modifying data in the wrong way!</p>
<h1 id="how-all-agb-games-start"><a class="header" href="#how-all-agb-games-start">How all agb games start</a></h1>
<p>Replace the content of the <code>main</code> function with the following:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">#[agb::entry]
</span><span class="boring">fn main(mut _gba: Gba) -&gt; ! {
</span>loop {} // infinite loop for now
<span class="boring">}
</span></code></pre>
<p>and ignore warnings for now.</p>
<h1 id="running-your-pong-game"><a class="header" href="#running-your-pong-game">Running your pong game</a></h1>
<p>Although there isn't much to see at the moment (just a black screen), you can start the game by using <code>cargo run</code> or whatever worked for you in the introduction.</p>
<h1 id="what-we-did"><a class="header" href="#what-we-did">What we did</a></h1>
<p>This was a very simple but incredibly important part of any game using <code>agb</code>.
All interactions with the hardware are gated via the Gba struct, which you never create yourself.</p>
<p>You are now ready to learn about display modes and how to start getting things onto the screen!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites"><a class="header" href="#sprites">Sprites</a></h1>
<p>In this section, we'll put the sprites needed for our pong game onto the screen.
We'll cover what sprites are in the Game Boy Advance, and how to get them to show up on screen.
We'll briefly cover vblank and by the end of this section, you'll have a ball bouncing around the screen!</p>
<h1 id="why-do-we-need-sprites-in-the-first-place"><a class="header" href="#why-do-we-need-sprites-in-the-first-place">Why do we need sprites in the first place?</a></h1>
<p>The Game Boy Advance has a 240x160px screen, with 15-bit RGB colour support.
In order to manually set the colour for each pixel in the screen, you would need to update a total of 38,400 pixels per frame, or 2,304,000 pixels per second at 60 fps.
With a 16MHz processor, that means you would need to be able to calculate 1 pixel every 8 clock cycles, which is pretty much impossible.
You could get clever with how you update these pixels, but using the tools provided by the Game Boy Advance to put pixels on the screen, you'll have a much easier time.</p>
<p>So there are 2 ways that the Game Boy Advance allows you to get these pixels on screen much more easily.
Tiles and sprites.
Tiles are 8x8 pixels in size and can be placed in a grid on the screen.
You can also scroll the whole tile layer to arbitrary positions, but the tiles will remain in this 8x8 pixel grid.
We'll cover tiles in more detail later.</p>
<p>The other way you can draw things on screen is using sprites, which we'll cover in more detail in this section.</p>
<h1 id="sprites-on-the-game-boy-advance"><a class="header" href="#sprites-on-the-game-boy-advance">Sprites on the Game Boy Advance</a></h1>
<p>The Game Boy Advance supports 256 hardware sprites.
These can be in one of many sizes, ranging from square 8x8 to more exotic sizes like 8x32 pixels.
For our pong game, all the sprites will be 16x16 pixels to make things a bit simpler.</p>
<p>Sprites are stored in the Game Boy Advance in a special area of video memory called the 'Object Attribute Memory' (OAM).
This has space for the 'attributes' of the sprites (things like whether or not they are visible, the location, which tile to use etc) but it does not store the actual pixel data.
The pixel data is stored in a video RAM (VRAM).
Because of this split, it is possible to have multiple sprites refer to the same tiles in video RAM which saves space and allows for more objects on screen at once then repeating them would otherwise allow.</p>
<p>Since RAM is in short supply, and at the time was quite expensive, the tile data is stored as indexed palette data.
So rather than storing the full colour data for each pixel in the tile, the Game Boy Advance instead stores a 'palette' of colours and the tiles which make up the sprites are stored as indexes to the palette.
You don't need to worry about this though, because <code>agb</code> handles it for you, but it is important to keep in mind that each sprite can use a maximum of 16 colours out of the total sprite palette of 256 colours.</p>
<p>There are technically 2 types of sprite, regular and affine sprites.
For now, we will only be dealing with regular sprites.</p>
<h1 id="import-the-sprite"><a class="header" href="#import-the-sprite">Import the sprite</a></h1>
<p>Firstly, you're going to need to import the sprites into your project.
<code>agb</code> has great support for the <a href="https://www.aseprite.org/">aseprite</a> sprite editor which can be bought for $20 or you can compile it yourself for free.
Aseprite files can be natively imported by <code>agb</code> for use on the Game Boy Advance.
Here is the sprite sheet we will use as a png, but you should <a href="pong/sprites.aseprite">download the aseprite file</a> and place it in <code>gfx/sprites.aseprite</code>.</p>
<p><img src="pong/sprites.png" alt="pong sprites" /></p>
<p>This contains 5 <code>16x16px</code> sprites.
The first is the end cap for the paddle.
The second is the centre part of the paddle, which could potentially be repeated a few times.
The third until the fifth is the ball, with various squashed states.
The aseprite file defines tags for these sprites, being &quot;Paddle End&quot;, &quot;Paddle Mid&quot;, and &quot;Ball&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use agb::{
    include_aseprite,
    display::object::{Graphics, Tag}
};

// Import the sprites in to this constant. This holds the sprite 
// and palette data in a way that is manageable by agb.
const GRAPHICS: &amp;Graphics = include_aseprite!(&quot;gfx/sprites.aseprite&quot;);

// We define some easy ways of referencing the sprites
const PADDLE_END: &amp;Tag = GRAPHICS.tags().get(&quot;Paddle End&quot;);
const PADDLE_MID: &amp;Tag = GRAPHICS.tags().get(&quot;Paddle Mid&quot;);
const BALL: &amp;Tag = GRAPHICS.tags().get(&quot;Ball&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This uses the <code>include_aseprite</code> macro to include the sprites in the given aseprite file.
Now, let's put this on screen by firstly creating the object manager and then creating an object, this will also involve the creation of the main entry function using the <code>entry</code> macro.
The signature of this function takes the <code>Gba</code> struct and has the never return type, this means Rust will enforce that this function never returns, for now we will achieve this using a busy loop.
Using the <code>Gba</code> struct we get the <a href="https://docs.rs/agb/latest/agb/display/object/struct.ObjectController.html"><code>ObjectController</code> struct</a> which manages loading and unloading sprites and objects.</p>
<pre><pre class="playground"><code class="language-rust">#[agb::entry]
fn main(gba: mut agb::Gba) -&gt; ! {
    // Get the object manager
    let object = gba.display.object.get();

    // Create an object with the ball sprite
    let mut ball = object.object_sprite(BALL.sprite(0));

    // Place this at some point on the screen, (50, 50) for example
    ball.set_x(50).set_y(50).show();

    // Now commit the object controller so this change is reflected on the screen.
    // This isn't how we will do this in the final version of the code, but will do
    // for this example.
    object.commit();
    
    loop {}
}
</code></pre></pre>
<p>If you run this you should now see the ball for this pong game somewhere in the top left of the screen.</p>
<h1 id="making-the-sprite-move"><a class="header" href="#making-the-sprite-move">Making the sprite move</a></h1>
<p>The GBA renders to the screen one pixel at a time a line at a time from left to right.
After it has finished rendering to each pixel of the screen, it briefly pauses rendering before starting again.
This period of no drawing is called <code>vblank</code>, which stands for the 'vertical blanking interval'.
There is also a 'horizontal blanking interval', but that is outside of the scope of this book.</p>
<p>You should <code>.commit()</code> your sprites only during this <code>vblank</code> phase, because otherwise you may end up moving a sprite during the rendering which could cause tearing of your objects<sup class="footnote-reference"><a href="#hblank">1</a></sup>.
<code>agb</code> provides a convenience function for waiting until the right moment called <code>agb::display::busy_wait_for_vblank()</code>.
You shouldn't use this is a real game (we'll do it properly later on), but for now we can use this to wait for the correct time to <code>commit</code> our sprites to memory.</p>
<p>Making the sprite move 1 pixel every frame (so 60 pixels per second) can be done as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// replace the call to object.commit() with the following:

let mut ball_x = 50;
let mut ball_y = 50;
let mut x_velocity = 1;
let mut y_velocity = 1;

loop {
    // This will calculate the new position and enforce the position
    // of the ball remains within the screen
    ball_x = (ball_x + x_velocity).clamp(0, agb::display::WIDTH - 16);
    ball_y = (ball_y + y_velocity).clamp(0, agb::display::HEIGHT - 16);

    // We check if the ball reaches the edge of the screen and reverse it's direction
    if ball_x == 0 || ball_x == agb::display::WIDTH - 16 {
        x_velocity = -x_velocity;
    }

    if ball_y == 0 || ball_y == agb::display::HEIGHT - 16 {
        y_velocity = -y_velocity;
    }

    // Set the position of the ball to match our new calculated position
    ball.set_x(ball_x as u16).set_y(ball_y as u16);

    // Wait for vblank, then commit the objects to the screen
    agb::display::busy_wait_for_vblank();
    object.commit();
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="what-we-did-1"><a class="header" href="#what-we-did-1">What we did</a></h1>
<p>In this section, we covered why sprites are important, how to create and manage them using the <code>ObjectController</code> in <code>agb</code> and make a ball bounce around the screen.</p>
<div class="footnote-definition" id="hblank"><sup class="footnote-definition-label">1</sup>
<p>Timing this can give you some really cool effects allowing you to push the hardware.
However, <code>agb</code> does not by default provide the timing accuracy needed to fully take advantage of this, erring on the side of making it easier to make games rather than squeezing every last drop of performance from the console.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controls"><a class="header" href="#controls">Controls</a></h1>
<p>In this section, we'll make the ball that we displayed in the last section move by pressing the D-Pad.</p>
<h1 id="the-gba-controls"><a class="header" href="#the-gba-controls">The GBA controls</a></h1>
<p>The GBA has 10 buttons we can read the state of, and this is the only way a player can directly control the game.
They are the 4 directions on the D-Pad, A, B, Start, Select, and the L and R triggers.</p>
<h1 id="reading-the-button-state"><a class="header" href="#reading-the-button-state">Reading the button state</a></h1>
<p>There are two ways to capture the button state in <strong>agb</strong>, interrupts and polling.
In most games, you will want to use polling, so that is what we will use now.
Interrupts will be covered in a later chapter.</p>
<p>To add button control to our game, we will need a <a href="https://docs.rs/agb/latest/agb/input/struct.ButtonController.html">ButtonController</a>.
Add this near the top of your main function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut input = agb::input::ButtonController::new();
<span class="boring">}
</span></code></pre></pre>
<p>The button controller is not part of the <code>Gba</code> struct because it only allows for reading and not writing so does not need to be controlled by the borrow checker.</p>
<p>Replace the inner loop with the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ball_x = 50;
let mut ball_y = 50;

// now we initialise the x and y velocities to 0 rather than 1
let mut x_velocity = 0;
let mut y_velocity = 0;

loop {
    ball_x = (ball_x + x_velocity).clamp(0, agb::display::WIDTH - 16);
    ball_y = (ball_y + y_velocity).clamp(0, agb::display::HEIGHT - 16);

    // x_tri and y_tri describe with -1, 0 and 1 which way the d-pad
    // buttons are being pressed
    x_velocity = input.x_tri() as i32;
    y_velocity = input.y_tri() as i32;
    
    ball.set_x(ball_x as u16).set_y(ball_y as u16);

    agb::display::busy_wait_for_vblank();
    object.commit();

    // We must call input.update() every frame otherwise it won't update based
    // on the actual button press state.
    input.update();
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we use the <code>x_tri()</code> and <code>y_tri()</code> methods.
They return instances of the <a href="https://docs.rs/agb/latest/agb/input/enum.Tri.html"><code>Tri</code></a> enum which describes which buttons are being pressed, and are very helpful in situations like these where you want to move something in a cardinal direction based on which buttons are pressed.</p>
<h1 id="detecting-individual-button-presses"><a class="header" href="#detecting-individual-button-presses">Detecting individual button presses</a></h1>
<p>If you want to detect if any button is pressed, you can use the <code>is_pressed</code> method on <code>ButtonController</code>.
For example, we can do the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use agb::input::Button;

if input.is_pressed(Button::A) {
    // the A button is pressed
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ButtonController</code> also provides the <code>is_just_pressed</code> method.
This will return true for 1 frame, the one where the player actually pressed the button.
From that point on, it'll return false again until the player presses it again.</p>
<h1 id="what-we-did-2"><a class="header" href="#what-we-did-2">What we did</a></h1>
<p>We added very basic button control to our bouncing ball example.
In the next step, we'll cover meta-sprites and actually add a bat to our game of pong.</p>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<p>Make it so the ball moves twice as fast if you're pressing the <code>A</code> button while moving it around.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
