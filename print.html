<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The agb book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="hardware/hardware.html"><strong aria-hidden="true">2.</strong> The Game Boy Advance hardware</a></li><li class="chapter-item expanded "><a href="setup/getting_started.html"><strong aria-hidden="true">3.</strong> Running an example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/setup.html"><strong aria-hidden="true">3.1.</strong> Environment setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/linux.html"><strong aria-hidden="true">3.1.1.</strong> Linux setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.2.</strong> Windows setup</div></li><li class="chapter-item expanded "><a href="setup/mac.html"><strong aria-hidden="true">3.1.3.</strong> Mac OS setup</a></li></ol></li><li class="chapter-item expanded "><a href="setup/building.html"><strong aria-hidden="true">3.2.</strong> Building the template</a></li></ol></li><li class="chapter-item expanded "><a href="pong/01_introduction.html"><strong aria-hidden="true">4.</strong> Learn agb part I - pong</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pong/02_the_gba_struct.html"><strong aria-hidden="true">4.1.</strong> The Gba struct</a></li><li class="chapter-item expanded "><a href="pong/03_sprites.html"><strong aria-hidden="true">4.2.</strong> Sprites</a></li><li class="chapter-item expanded "><a href="pong/04_controls.html"><strong aria-hidden="true">4.3.</strong> Controls</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The agb book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>agb</strong> is a powerful and easy-to-use library for writing games for the Game Boy Advance (GBA) in rust.
It provides an abstracted interface to the hardware, allowing you to take full advantage of its capabilities without needing to know the low-level details of its implementation.</p>
<h2 id="a-little-bit-about-agb"><a class="header" href="#a-little-bit-about-agb">A little bit about agb</a></h2>
<p><code>agb</code> is a library for making games on the Game Boy Advance using the Rust
programming language. The library's main focus is to provide an abstraction
that allows you to develop games which take advantage of the GBA's capabilities
without needing to have extensive knowledge of its low-level implementation.</p>
<p>agb provides the following features:</p>
<ul>
<li>Simple build process with minimal dependencies</li>
<li>Built in importing of sprites, backgrounds, music and sound effects</li>
<li>High performance audio mixer</li>
<li>Easy to use sprite and tiled background usage</li>
<li>A global allocator allowing for use of both <code>core</code> and <code>alloc</code></li>
</ul>
<h2 id="why-rust"><a class="header" href="#why-rust">Why rust?</a></h2>
<p>Rust is an excellent choice of language for developing games on low-level embedded hardware like the GBA.
Its strong type system, memory safety, and performance optimizations make it well-suited for building reliable and efficient code in this context.</p>
<p>Agb leverages rust's unique features by using the type system to model the GBA's hardware.
This approach helps prevent common programming errors and allows developers to quickly build games that function correctly on the GBA platform.</p>
<p>In addition to safety and correctness, rust's performance optimizations are crucial for developing games on the GBA's slow processor.
With a limited amount of time per frame, every optimization counts, and rust's speed and efficiency help ensure that games built with agb run smoothly on the GBA hardware.</p>
<h1 id="what-is-in-this-book"><a class="header" href="#what-is-in-this-book">What is in this book?</a></h1>
<p>This book serves as an introduction to agb, showcasing its capabilities and providing guidance on how to use it to build your own GBA games.
It assumes that you have some experience with rust and game development, and provides detailed explanations of the unique challenges of writing games for the GBA.</p>
<h1 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this book for?</a></h1>
<p>This book is ideal for anyone interested in writing games for the GBA using rust.
If you're new to either rust or game development, you may want to start with some introductory resources before diving into this book.
This book assumes a basic understanding of rust syntax and semantics, as well as game development concepts.</p>
<h1 id="helpful-links"><a class="header" href="#helpful-links">Helpful links</a></h1>
<ul>
<li><a href="https://github.com/agbrs/agb">agb's GitHub</a> is the primary development hub for the library.</li>
<li><a href="https://github.com/agbrs/agb/discussions">agb's Discussion Page</a> is a helpful forum where you can ask for help on using agb or share your projects with the community.</li>
<li><a href="https://crates.io/crates/agb">agb's crates.io page</a> the latest version of the library on crates.io.</li>
<li><a href="https://docs.rs/agb">agb's documentation</a> is a useful reference for the library's API and features.</li>
<li><a href="https://github.com/gbdev/awesome-gbadev">Awesome Game Boy Advance development</a> is a comprehensive resource for GBA development, with links to popular libraries, emulators, and the friendly gbadev Discord server.</li>
<li><a href="https://github.com/agbrs/agb/releases/latest">Example games</a> built using agb can be found in the <code>examples.zip</code> file attached to the latest release. Additionally, you can also check out <a href="https://lostimmortal.itch.io/the-hat-chooses-the-wizard">The Hat Chooses the Wizard</a>, a game written using agb as part of the GMTK 2021 game jam.</li>
</ul>
<p>In addition to these resources, this book provides step-by-step instructions for getting started with agb.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-game-boy-advance-hardware"><a class="header" href="#the-game-boy-advance-hardware">The Game Boy Advance hardware</a></h1>
<p>The Game Boy Advance is a handheld gaming console released by Nintendo in March 2001 in Japan and in North America in June of the same year.
It features a 2.9 inch screen with a 240x144 pixel resolution and is powered by a 32-bit 16.8MHz ARM CPU.
The console was developed as a successor to the Game Boy Color and was internally codenamed the 'Advanced Game Boy' (agb), which is where this crate gets its name.</p>
<h1 id="what-makes-the-gba-unique"><a class="header" href="#what-makes-the-gba-unique">What makes the GBA unique?</a></h1>
<p>The Game Boy Advance is a (fairly) unique console among retro handheld consoles.
It was developed at a time when processors were not powerful enough to push an entire screen of pixels to the screen every frame.
As a result, it features a special Pixel Processing Unit (PPU) that is similar to a modern-day graphics card, but is optimized for gaming.
The console has a concept of &quot;hardware sprites&quot; and &quot;hardware backgrounds,&quot; which we will explain in more detail in the next section.
These hardware 2D capabilities give the GBA its unique characteristics.</p>
<p>Despite being a retro console, the GBA is still compatible with modern tools and programming languages thanks to the ARM CPU it contains.
The CPU is modern enough to be supported by LLVM and Rust, which provide a reasonably trouble-free experience.
This allows developers to take advantage of modern tooling while experiencing what it was like to program for retro consoles at the time.</p>
<h1 id="capabilities-of-the-hardware"><a class="header" href="#capabilities-of-the-hardware">Capabilities of the hardware</a></h1>
<p>The GBA is fundamentally a 2D system, and a lot of the hardware accelerated graphics is designed to support this.
The relevant features for this book are:</p>
<ul>
<li>256 sprites which can be from 8x8 to 64x64 pixels in size</li>
<li>4 background layers which are enabled / disabled depending on the graphics mode</li>
<li>Background tiles, 8x8 pixel tiles are used in the background layers if they are in tile mode.</li>
<li>8-bit sound. You have the ability to send 8-bit raw audio data to the speakers, optionally stereo.</li>
</ul>
<p>You can read more about the specifics of the GBA on <a href="https://rust-console.github.io/gbatek-gbaonly/">gbatek</a>.
To simplify the development process, agb abstracts some of the GBA's hardware away from the developer, which reduces the number of things to remember and lessens the chance of something going wrong.
If you wish to experiment with the hardware directly, the best place to look is <a href="https://www.coranac.com/tonc/text/">tonc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-an-example"><a class="header" href="#running-an-example">Running an example</a></h1>
<p>In this section, we will get to the point where you can build and run the agb template repository.
This will prove that your development environment is ready for the future tutorials and later building.</p>
<p>You can run the game using real hardware and a flash card.
However, at this stage, it is much easier to play on an emulator.
agb is guaranteed to work well using <a href="https://mgba.io/">mgba</a>, but other emulators will also work.</p>
<p>Note that some emulators will require a special 'fixed' gba ROM file.
See the later steps in this section for how to do this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-setup"><a class="header" href="#environment-setup">Environment setup</a></h1>
<p>Environment setup will depend on the platform you are using.
agb's requirements are <a href="https://www.rust-lang.org/">rust nightly</a> edition and the gnu binutils for <code>arm-none-eabi</code>.</p>
<p>See the sub-pages here for platform specific setup guides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-setup"><a class="header" href="#linux-setup">Linux setup</a></h1>
<p>This guide has been tested on Ubuntu, Arch Linux and Raspberry Pi OS running on a raspberry pi 4.</p>
<h1 id="1-install-a-recent-version-of-rust"><a class="header" href="#1-install-a-recent-version-of-rust">1. Install a recent version of rust</a></h1>
<p>To use agb, you'll need to use nightly rust since it requires a few nightly features.
Firstly, ensure that you have <strong>rustup</strong> installed which you can do by following the instructions on the <a href="https://www.rust-lang.org/tools/install">rust website</a></p>
<p>If you have already installed rustup, you can update it with <code>rustup update</code>.</p>
<h1 id="2-arm-none-eabi"><a class="header" href="#2-arm-none-eabi">2. arm-none-eabi</a></h1>
<p>To assemble the small amount of assembly in agb and to do the final linking, you'll need to install the <code>arm-none-eabi</code> binutils.</p>
<ul>
<li>On Debian and derivatives (like Ubuntu): <code>sudo apt install binutils-arm-none-eabi</code></li>
<li>On Arch Linux and derivatives: <code>pacman -S arm-none-eabi-binutils</code></li>
</ul>
<h1 id="3-git"><a class="header" href="#3-git">3. git</a></h1>
<p>The source code for the game is hosted on github, so you will need to install git.</p>
<ul>
<li>On Debian and derivatives (like Ubuntu): <code>sudo apt install git</code></li>
<li>On Arch Linux and derivatives: <code>pacman -S git</code></li>
</ul>
<h1 id="4-gbafix"><a class="header" href="#4-gbafix">4. gbafix</a></h1>
<p>In order to be able to play games made with agb on real hardware or on some emulators, you will need to install 'agb-gbafix'.
Agb's implementation can be installed very easily using <code>cargo install agb-gbafix</code>.</p>
<p>Make sure that the Cargo bin directory is in your <code>PATH</code> as we'll need to use it later.</p>
<p>That is all you need to get started!
You can now move on to 'building the game'.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac-setup"><a class="header" href="#mac-setup">Mac setup</a></h1>
<p>This guide has been tested on MacOS 13.0.1 on an M1 chip.</p>
<h1 id="1-install-a-recent-version-of-rust-1"><a class="header" href="#1-install-a-recent-version-of-rust-1">1. Install a recent version of rust</a></h1>
<p>To use agb, you'll need to use nightly rust since it requires a few nightly features.
Firstly, ensure that you have <strong>rustup</strong> installed which you can do by following the instructions on the <a href="https://www.rust-lang.org/tools/install">rust website</a></p>
<p>If you have already installed rustup, you can update it with <code>rustup update</code>.</p>
<h1 id="2-install-arm-none-eabi"><a class="header" href="#2-install-arm-none-eabi">2. Install arm-none-eabi</a></h1>
<p>To assemble the small amount of assembly in agb and to do the final linking, you'll need to install the <code>arm-none-eabi</code> binutils.</p>
<h2 id="install-from-arm"><a class="header" href="#install-from-arm">Install from ARM</a></h2>
<p>Download the toolchain from <a href="https://developer.arm.com/downloads/-/gnu-rm">ARM here</a></p>
<ul>
<li>Run the .pkg to install</li>
<li>Add <code>/Applications/ARM/bin</code> to your <code>/etc/paths</code> file</li>
</ul>
<h2 id="install-from-homebrew"><a class="header" href="#install-from-homebrew">Install from Homebrew</a></h2>
<p>Or you can try installing with homebrew from the <a href="https://github.com/ARMmbed/homebrew-formulae">Arm Mbed repo</a>:</p>
<pre><code>brew tap ArmMbed/homebrew-formulae
brew install arm-none-eabi-gcc
</code></pre>
<h1 id="3-get-git"><a class="header" href="#3-get-git">3. Get git</a></h1>
<p>The source code for the game is hosted on github, so you will need git installed. Follow the instructions at <a href="https://git-scm.com/">git-scm.com</a></p>
<h1 id="4-gba-emulator---mgba"><a class="header" href="#4-gba-emulator---mgba">4. GBA Emulator - mGBA</a></h1>
<p>We recommend using the mGBA emulator which you can download for Mac <a href="https://mgba.io/downloads.html">here</a>.</p>
<p>After installing to your <code>/Applications</code> folder you can add the binary to your path and create an alias for the agb run command to use.</p>
<ul>
<li>Add <code>/Applications/mGBA.app/Contents/MacOS</code> to <code>/etc/paths</code></li>
<li>Inside the <code>/Applications/mGBA.app/Contents/MacOS</code> directory (in a terminal) run: <code>ln -s mGBA mgba-qt</code></li>
</ul>
<h1 id="5-real-hardware---gbafix"><a class="header" href="#5-real-hardware---gbafix">5. Real hardware - gbafix</a></h1>
<p>In order to be able to play games made with agb on real hardware or on some emulators, you will need to install 'agb-gbafix'.
Agb's implementation can be installed very easily using <code>cargo install agb-gbafix</code>.</p>
<p>Make sure that the Cargo bin directory is in your <code>PATH</code> as we'll need to use it later.</p>
<p>That is all you need to get started!
You can now move on to 'building the game'.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-running-the-agb-template"><a class="header" href="#building-and-running-the-agb-template">Building and running the agb template</a></h1>
<p>In this section, you will learn how to build and run the agb template.
By the end of this section, you will have a working GBA game that you can run on your emulator of choice.</p>
<h2 id="1-clone-the-repository"><a class="header" href="#1-clone-the-repository">1. Clone the repository</a></h2>
<p>The first step is to clone the agb template repository using Git.
Open a terminal or command prompt and run the following command:</p>
<pre><code class="language-sh">git clone https://github.com/agbrs/template.git
</code></pre>
<p>This will create a copy of the agb template repository on your local machine.</p>
<h2 id="2-build-the-template"><a class="header" href="#2-build-the-template">2. Build the template</a></h2>
<p>Next, navigate to the <code>template</code> directory in the repository and build the template using the following command:</p>
<pre><code class="language-sh">cd template
cargo build --release
</code></pre>
<p>This command will compile the agb template in release mode.
The resulting binary file can be found in the <code>target/thumbv4t-none-eabi/release</code> directory.
Depending on your platform, the file will have either a <code>.elf</code> extension or no extension.</p>
<h2 id="3-convert-the-binary-to-a-gba-file"><a class="header" href="#3-convert-the-binary-to-a-gba-file">3. Convert the binary to a GBA file</a></h2>
<p>In order to run the game on an emulator, we need to convert the binary file to a GBA file.
To do this, we'll use the tool <code>agb-gbafix</code>.</p>
<p>Run the following command to convert the binary file to a GBA ROM:</p>
<pre><code class="language-sh">agb-gbafix target/thumbv4t-none-eabi/release/template -o template.gba
</code></pre>
<p>or</p>
<pre><code class="language-sh">agb-gbafix target/thumbv4t-none-eabi/release/template.elf -o template.gba
</code></pre>
<p>This command will add the correct GBA header to the template.gba file and it will be playable on real hardware or an emulator.</p>
<h2 id="4-run-the-game"><a class="header" href="#4-run-the-game">4. Run the game</a></h2>
<p>Finally, you can run the game on your emulator of choice.
Load the template.gba file in your emulator, and you should see the agb template running.</p>
<p>If you have mgba-qt installed on your machine, you can run the game directly from the command line using the following command:</p>
<pre><code class="language-sh">cargo run --release
</code></pre>
<p>This will build and run the agb template in a single step.</p>
<p>That's it! You now have a working agb template that you can use as a starting point for your own GBA game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learn-agb-part-i-pong"><a class="header" href="#learn-agb-part-i-pong">Learn agb part I: Pong</a></h1>
<p>In this section, you'll learn how to make a simple pong-style game for the Game Boy Advance using agb.
By following the steps in this section below, you'll gain an understanding of:</p>
<ul>
<li>How to use tiled graphics modes.</li>
<li>How to import graphics using <code>agb</code>.</li>
<li>What Game Boy Advance sprites are, how to create them, and how to display them on the screen.</li>
<li>How to detect button input and use it to control game objects.</li>
<li>How to add a static background to your game.</li>
<li>How to make a dynamic background to display scores.</li>
<li>How to add music and sound effects to your game.</li>
</ul>
<p>With this knowledge, you'll be well equipped to start making your own games for the GBA!</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>To get started, create a new repository based on the <a href="https://github.com/agbrs/template">agb template</a> and name it <code>pong</code>.</p>
<p>Next, update the <code>name</code> field in <code>Cargo.toml</code> to <code>pong</code> like so:</p>
<pre><code class="language-toml">[package]
name = &quot;pong&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your name here&quot;]
edition = &quot;2021&quot;

# ...
</code></pre>
<p>Now, you're ready to dive and and start learning about <code>agb</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gba-struct"><a class="header" href="#the-gba-struct">The Gba struct</a></h1>
<p>In this section, we'll cover the importance of the Gba struct and how it gets created for you.</p>
<h1 id="the-importance-of-the-gba-struct"><a class="header" href="#the-importance-of-the-gba-struct">The importance of the Gba struct</a></h1>
<p>The <a href="https://docs.rs/agb/latest/agb/struct.Gba.html">Gba singleton struct</a> is a crucial part of agb game development.
It is used for almost all interactions with the Game Boy Advance's hardware, such as graphics rendering, timer access and audio playback.</p>
<p>You should not create the Gba struct yourself. Instead, it is passed to your main function as an owned reference.
This allows rust's borrow checker to ensure that access to the Game Boy Advance hardware is done in a safe and sensible manner, preventing two bits of your code from modifying data in the wrong way.</p>
<h1 id="how-all-agb-games-start"><a class="header" href="#how-all-agb-games-start">How all agb games start</a></h1>
<p>To use the Gba struct in your agb game, you'll need to create a function (normally called <code>main</code>) which takes an owned reference to the Gba instance.
The recommended way to do this is by using the <code>#[agb::entry]</code> attribute macro provided by the <code>agb</code> crate.</p>
<p>Replace the content of the <code>main</code> function with the following:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">#[agb::entry]
</span><span class="boring">fn main(mut _gba: Gba) -&gt; ! {
</span>loop {} // infinite loop for now
<span class="boring">}
</span></code></pre>
<p>This creates an infinite loop and allows you to start building your game.</p>
<h1 id="running-your-pong-game"><a class="header" href="#running-your-pong-game">Running your pong game</a></h1>
<p>At this point, your game won't do much except display a black screen. To run your game, use the <code>cargo run</code> command as before.</p>
<h1 id="what-we-covered"><a class="header" href="#what-we-covered">What we covered</a></h1>
<p>In this section, we covered the importance of the Gba struct in agb game development.
By using the Gba struct as a gatekeeper for all hardware interactions, you can ensure that your code is safe and efficient.
You are now ready to learn about sprites and start getting things onto the screen!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprites"><a class="header" href="#sprites">Sprites</a></h1>
<p>In this section, we'll cover what sprites are in the Game Boy Advance and how to put them on the screen in our pong game.
We'll briefly cover vblank, and by the end of this section, you'll have a ball bouncing around the screen!</p>
<h1 id="why-do-we-need-sprites"><a class="header" href="#why-do-we-need-sprites">Why do we need sprites?</a></h1>
<p>The Game Boy Advance has a 240x160px screen with 15-bit RGB color support. Setting the color for each pixel manually would require updating 38,400 pixels per frame, or 2,304,000 pixels per second at 60 fps.
With a 16 MHz processor, this means calculating 1 pixel every 8 clock cycles, which is pretty much impossible. 
he Game Boy Advance provides two ways to easily put pixels on the screen: tiles and sprites.</p>
<p>Tiles are 8x8 pixels in size and can be placed in a grid on the screen.
You can also scroll the whole tile layer to arbitrary positions, but the tiles will remain in this 8x8 pixel grid.</p>
<p>Sprites are the other way to draw things on the screen, which we'll cover in this section.
The Game Boy Advance supports 256 hardware sprites, with different sizes ranging from square 8x8 to more exotic sizes like 8x32 pixels.
In our pong game, all the sprites will be 16x16 pixels to make things simpler.</p>
<p>Sprites are stored in a special area of video memory called the 'Object Attribute Memory' (OAM).
OAM has space for the 'attributes' of the sprites, such as their location, whether or not they are visible, and which tile to use, but it does not store the actual pixel data.
The pixel data is stored in video RAM (VRAM).
This split allows multiple sprites to refer to the same tiles in VRAM, which saves space and allows for more objects on screen than would be possible by repeating them.</p>
<p>Since RAM is in short supply and expensive, the tile data is stored as indexed palette data.
Instead of storing the full color data for each pixel in the tile, the Game Boy Advance stores a 'palette' of colors, and the tiles that make up the sprites are stored as indexes to the palette.
Each sprite can use a maximum of 16 colors out of the total sprite palette of 256 colors.</p>
<p>There are technically two types of sprites: regular and affine sprites.
For now, we will only be dealing with regular sprites.</p>
<h1 id="import-the-sprite"><a class="header" href="#import-the-sprite">Import the sprite</a></h1>
<p>Firstly, you're going to need to import the sprites into your project.
<code>agb</code> has excellent support for the <a href="https://www.aseprite.org/">aseprite</a> sprite editor which can be bought for $20 or you can compile it yourself for free.
Aseprite files can be natively imported by <code>agb</code> for use on the Game Boy Advance.
Here is the sprite sheet we will use as a png, but you should <a href="pong/sprites.aseprite">download the aseprite file</a> and place it in <code>gfx/sprites.aseprite</code>.</p>
<p><img src="pong/sprites.png" alt="pong sprites" /></p>
<p>This contains 5 <code>16x16px</code> sprites: the end cap for the paddle, the center part of the paddle, which could potentially be repeated a few times, and the ball with various squashed states.
The aseprite file defines tags for these sprites: &quot;Paddle End,&quot; &quot;Paddle Mid,&quot; and &quot;Ball.&quot;</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use agb::{
    include_aseprite,
    display::object::{Graphics, Tag}
};

// Import the sprites in to this constant. This holds the sprite 
// and palette data in a way that is manageable by agb.
const GRAPHICS: &amp;Graphics = include_aseprite!(&quot;gfx/sprites.aseprite&quot;);

// We define some easy ways of referencing the sprites
const PADDLE_END: &amp;Tag = GRAPHICS.tags().get(&quot;Paddle End&quot;);
const PADDLE_MID: &amp;Tag = GRAPHICS.tags().get(&quot;Paddle Mid&quot;);
const BALL: &amp;Tag = GRAPHICS.tags().get(&quot;Ball&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This uses the <code>include_aseprite</code> macro to include the sprites in the given aseprite file.
Now, let's put this on screen by firstly creating the object manager and then creating an object, this will also involve the creation of the main entry function using the <code>entry</code> macro.
The signature of this function takes the <code>Gba</code> struct and has the never return type, this means Rust will enforce that this function never returns, for now we will achieve this using a busy loop.
Using the <code>Gba</code> struct we get the <a href="https://docs.rs/agb/latest/agb/display/object/struct.ObjectController.html"><code>ObjectController</code> struct</a> which manages loading and unloading sprites and objects.</p>
<pre><pre class="playground"><code class="language-rust">#[agb::entry]
fn main(gba: mut agb::Gba) -&gt; ! {
    // Get the object manager
    let object = gba.display.object.get();

    // Create an object with the ball sprite
    let mut ball = object.object_sprite(BALL.sprite(0));

    // Place this at some point on the screen, (50, 50) for example
    ball.set_x(50).set_y(50).show();

    // Now commit the object controller so this change is reflected on the screen.
    // This isn't how we will do this in the final version of the code, but will do
    // for this example.
    object.commit();
    
    loop {}
}
</code></pre></pre>
<p>If you run this you should now see the ball for this pong game somewhere in the top left of the screen.</p>
<h1 id="making-the-sprite-move"><a class="header" href="#making-the-sprite-move">Making the sprite move</a></h1>
<p>The GBA renders to the screen one pixel at a time a line at a time from left to right.
After it has finished rendering to each pixel of the screen, it briefly pauses rendering before starting again.
This period of no drawing is called <code>vblank</code>, which stands for the 'vertical blanking interval'.
There is also a 'horizontal blanking interval', but that is outside of the scope of this book.</p>
<p>You should <code>.commit()</code> your sprites only during this <code>vblank</code> phase, because otherwise you may end up moving a sprite during the rendering which could cause tearing of your objects<sup class="footnote-reference"><a href="#hblank">1</a></sup>.
<code>agb</code> provides a convenience function for waiting until the right moment called <code>agb::display::busy_wait_for_vblank()</code>.
You shouldn't use this is a real game (we'll do it properly later on), but for now we can use this to wait for the correct time to <code>commit</code> our sprites to memory.</p>
<p>Making the sprite move 1 pixel every frame (so 60 pixels per second) can be done as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// replace the call to object.commit() with the following:

let mut ball_x = 50;
let mut ball_y = 50;
let mut x_velocity = 1;
let mut y_velocity = 1;

loop {
    // This will calculate the new position and enforce the position
    // of the ball remains within the screen
    ball_x = (ball_x + x_velocity).clamp(0, agb::display::WIDTH - 16);
    ball_y = (ball_y + y_velocity).clamp(0, agb::display::HEIGHT - 16);

    // We check if the ball reaches the edge of the screen and reverse it's direction
    if ball_x == 0 || ball_x == agb::display::WIDTH - 16 {
        x_velocity = -x_velocity;
    }

    if ball_y == 0 || ball_y == agb::display::HEIGHT - 16 {
        y_velocity = -y_velocity;
    }

    // Set the position of the ball to match our new calculated position
    ball.set_x(ball_x as u16).set_y(ball_y as u16);

    // Wait for vblank, then commit the objects to the screen
    agb::display::busy_wait_for_vblank();
    object.commit();
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="what-we-did"><a class="header" href="#what-we-did">What we did</a></h1>
<p>In this section, we covered why sprites are important, how to create and manage them using the <code>ObjectController</code> in <code>agb</code> and make a ball bounce around the screen.</p>
<div class="footnote-definition" id="hblank"><sup class="footnote-definition-label">1</sup>
<p>Timing this can give you some really cool effects allowing you to push the hardware.
However, <code>agb</code> does not by default provide the timing accuracy needed to fully take advantage of this, erring on the side of making it easier to make games rather than squeezing every last drop of performance from the console.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controls"><a class="header" href="#controls">Controls</a></h1>
<p>In this section, we'll make the ball that we displayed in the last section move by pressing the D-Pad.</p>
<h1 id="the-gba-controls"><a class="header" href="#the-gba-controls">The GBA controls</a></h1>
<p>The GBA has 10 buttons we can read the state of, and this is the only way a player can directly control the game.
They are the 4 directions on the D-Pad, A, B, Start, Select, and the L and R triggers.</p>
<h1 id="reading-the-button-state"><a class="header" href="#reading-the-button-state">Reading the button state</a></h1>
<p>There are two ways to capture the button state in <strong>agb</strong>, interrupts and polling.
In most games, you will want to use polling, so that is what we will use now.
Interrupts will be covered in a later chapter.</p>
<p>To add button control to our game, we will need a <a href="https://docs.rs/agb/latest/agb/input/struct.ButtonController.html">ButtonController</a>.
Add this near the top of your main function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut input = agb::input::ButtonController::new();
<span class="boring">}
</span></code></pre></pre>
<p>The button controller is not part of the <code>Gba</code> struct because it only allows for reading and not writing so does not need to be controlled by the borrow checker.</p>
<p>Replace the inner loop with the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut ball_x = 50;
let mut ball_y = 50;

// now we initialise the x and y velocities to 0 rather than 1
let mut x_velocity = 0;
let mut y_velocity = 0;

loop {
    ball_x = (ball_x + x_velocity).clamp(0, agb::display::WIDTH - 16);
    ball_y = (ball_y + y_velocity).clamp(0, agb::display::HEIGHT - 16);

    // x_tri and y_tri describe with -1, 0 and 1 which way the d-pad
    // buttons are being pressed
    x_velocity = input.x_tri() as i32;
    y_velocity = input.y_tri() as i32;
    
    ball.set_x(ball_x as u16).set_y(ball_y as u16);

    agb::display::busy_wait_for_vblank();
    object.commit();

    // We must call input.update() every frame otherwise it won't update based
    // on the actual button press state.
    input.update();
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we use the <code>x_tri()</code> and <code>y_tri()</code> methods.
They return instances of the <a href="https://docs.rs/agb/latest/agb/input/enum.Tri.html"><code>Tri</code></a> enum which describes which buttons are being pressed, and are very helpful in situations like these where you want to move something in a cardinal direction based on which buttons are pressed.</p>
<h1 id="detecting-individual-button-presses"><a class="header" href="#detecting-individual-button-presses">Detecting individual button presses</a></h1>
<p>If you want to detect if any button is pressed, you can use the <code>is_pressed</code> method on <code>ButtonController</code>.
For example, we can do the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use agb::input::Button;

if input.is_pressed(Button::A) {
    // the A button is pressed
}
<span class="boring">}
</span></code></pre></pre>
<p><code>ButtonController</code> also provides the <code>is_just_pressed</code> method.
This will return true for 1 frame, the one where the player actually pressed the button.
From that point on, it'll return false again until the player presses it again.</p>
<h1 id="what-we-did-1"><a class="header" href="#what-we-did-1">What we did</a></h1>
<p>We added very basic button control to our bouncing ball example.
In the next step, we'll cover meta-sprites and actually add a bat to our game of pong.</p>
<h1 id="exercise"><a class="header" href="#exercise">Exercise</a></h1>
<p>Make it so the ball moves twice as fast if you're pressing the <code>A</code> button while moving it around.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
